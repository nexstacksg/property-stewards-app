generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// Application users for admin access
model User {
  id           String   @id @default(cuid())
  username     String   @unique
  email        String   @unique
  passwordHash String
  role         Role     @default(ADMIN)
  confirmed    Boolean  @default(false)
}

model Customer {
  id              String            @id @default(cuid())
  name            String
  type            CustomerType
  personInCharge  String
  email           String
  phone           String
  isMember        Boolean           @default(false)
  memberSince     DateTime?
  memberExpiredOn DateTime?
  memberTier      MemberTier?
  billingAddress  String
  remarks         String?
  createdOn       DateTime          @default(now())
  updatedOn       DateTime          @updatedAt
  status          Status            @default(ACTIVE)
  contracts       Contract[]
  addresses       CustomerAddress[]

  @@index([email])
  @@index([phone])
  @@index([status])
}

model CustomerAddress {
  id           String       @id @default(cuid())
  customerId   String
  address      String
  postalCode   String
  propertyType PropertyType
  propertySize PropertySize
  remarks      String?
  createdOn    DateTime     @default(now())
  updatedOn    DateTime     @updatedAt
  status       Status       @default(ACTIVE)
  contracts    Contract[]
  customer     Customer     @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([customerId])
  @@index([status])
}

model Inspector {
  id             String                  @id @default(cuid())
  name           String
  mobilePhone    String                  @unique
  type           InspectorType
  specialization String?
  remarks        String?
  createdOn      DateTime                @default(now())
  updatedOn      DateTime                @updatedAt
  status         Status                  @default(ACTIVE)
  checklistItems ContractChecklistItem[]
  workOrders     WorkOrder[]
  itemEntries    ItemEntry[]

  @@index([mobilePhone])
  @@index([status])
}

model Checklist {
  id           String          @id @default(cuid())
  name         String
  propertyType PropertyType
  remarks      String?
  createdOn    DateTime        @default(now())
  updatedOn    DateTime        @updatedAt
  status       Status          @default(ACTIVE)
  items        ChecklistItem[]
  contracts    Contract[]

  @@index([propertyType])
  @@index([status])
}

model ChecklistItem {
  id          String    @id @default(cuid())
  checklistId String
  name        String
  action      String
  order       Int
  checklist   Checklist @relation(fields: [checklistId], references: [id], onDelete: Cascade)

  @@unique([checklistId, order])
  @@index([checklistId])
}

model Contract {
  id                 String             @id @default(cuid())
  customerId         String
  addressId          String
  value              Decimal            @db.Decimal(10, 2)
  firstPaymentOn     DateTime
  finalPaymentOn     DateTime?
  basedOnChecklistId String?
  scheduledStartDate DateTime
  scheduledEndDate   DateTime
  actualStartDate    DateTime?
  actualEndDate      DateTime?
  remarks            String?
  servicePackage     String?
  contractType       ContractType       @default(INSPECTION)
  customerComments   String?
  customerRating     Int?
  createdOn          DateTime           @default(now())
  updatedOn          DateTime           @updatedAt
  status             ContractStatus     @default(DRAFT)
  address            CustomerAddress    @relation(fields: [addressId], references: [id])
  basedOnChecklist   Checklist?         @relation(fields: [basedOnChecklistId], references: [id])
  customer           Customer           @relation(fields: [customerId], references: [id])
  contractChecklist  ContractChecklist?
  workOrders         WorkOrder[]

  @@index([customerId])
  @@index([addressId])
  @@index([status])
  @@index([scheduledStartDate])
}

model ContractChecklist {
  id         String                  @id @default(cuid())
  contractId String                  @unique
  createdOn  DateTime                @default(now())
  updatedOn  DateTime                @updatedAt
  status     Status                  @default(ACTIVE)
  contract   Contract                @relation(fields: [contractId], references: [id], onDelete: Cascade)
  items      ContractChecklistItem[]
}

model ContractChecklistItem {
  id                  String            @id @default(cuid())
  contractChecklistId String
  name                String
  remarks             String?
  photos              String[]
  videos              String[]
  enteredOn           DateTime?
  enteredById         String?
  workOrderId         String?
  order               Int
  tasks               Json?
  status              ChecklistItemStatus @default(PENDING)
  condition           Condition?
  contractChecklist   ContractChecklist @relation(fields: [contractChecklistId], references: [id], onDelete: Cascade)
  enteredBy           Inspector?        @relation(fields: [enteredById], references: [id])
  workOrder           WorkOrder?        @relation(fields: [workOrderId], references: [id])
  contributions       ItemEntry[]

  @@unique([contractChecklistId, order])
  @@index([contractChecklistId])
  @@index([workOrderId])
}

// Per-inspector contribution to a checklist item (remarks/media/selection)
model ItemEntry {
  id          String   @id @default(cuid())
  itemId      String
  inspectorId String
  remarks     String?
  photos      String[]
  videos      String[]
  includeInReport Boolean @default(false)
  createdOn   DateTime @default(now())
  updatedOn   DateTime @updatedAt

  item        ContractChecklistItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  inspector   Inspector @relation(fields: [inspectorId], references: [id])

  @@unique([itemId, inspectorId])
  @@index([itemId])
  @@index([inspectorId])
}

model WorkOrder {
  id                     String                  @id @default(cuid())
  contractId             String
  scheduledStartDateTime DateTime
  scheduledEndDateTime   DateTime
  actualStart            DateTime?
  actualEnd              DateTime?
  signature              String?
  signOffBy              String?
  remarks                String?
  createdOn              DateTime                @default(now())
  updatedOn              DateTime                @updatedAt
  status                 WorkOrderStatus         @default(SCHEDULED)
  checklistItems         ContractChecklistItem[]
  contract               Contract                @relation(fields: [contractId], references: [id])
  inspectors             Inspector[]

  @@index([contractId])
  @@index([status])
  @@index([scheduledStartDateTime])
}

// New Property table to manage available property types dynamically
model Property {
  id        String   @id @default(cuid())
  code      String   @unique
  name      String
  createdOn DateTime @default(now())
  updatedOn DateTime @updatedAt
  status    Status   @default(ACTIVE)
  sizes     PropertySizeOption[]

  @@index([status])
}

// Property size options linked to Property (type)
model PropertySizeOption {
  id         String   @id @default(cuid())
  propertyId String
  code       String
  name       String
  createdOn  DateTime @default(now())
  updatedOn  DateTime @updatedAt
  status     Status   @default(ACTIVE)

  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@unique([propertyId, code])
  @@index([propertyId])
  @@index([status])
}

enum CustomerType {
  INDIVIDUAL
  COMPANY
}

enum MemberTier {
  BRONZE
  SILVER
  GOLD
}

enum PropertyType {
  HDB
  CONDO
  EC
  APARTMENT
  LANDED
}

enum PropertySize {
  HDB_1_ROOM
  HDB_2_ROOM
  HDB_3_ROOM
  HDB_4_ROOM
  HDB_5_ROOM
  HDB_EXECUTIVE
  HDB_JUMBO
  STUDIO
  ONE_BEDROOM
  TWO_BEDROOM
  THREE_BEDROOM
  FOUR_BEDROOM
  PENTHOUSE
  TERRACE
  SEMI_DETACHED
  DETACHED
  BUNGALOW
  GOOD_CLASS_BUNGALOW
}

// Status for contract checklist items
enum ChecklistItemStatus {
  PENDING
  COMPLETED
}

// Physical condition options for checklist items
enum Condition {
  GOOD
  FAIR
  UNSATISFACTORY
  NOT_APPLICABLE
  UN_OBSERVABLE
}

enum InspectorType {
  FULL_TIME
  PART_TIME
}

enum Status {
  ACTIVE
  INACTIVE
}

enum ContractStatus {
  DRAFT
  CONFIRMED
  SCHEDULED
  COMPLETED
  CLOSED
  CANCELLED
}

enum ContractType {
  INSPECTION
  REPAIR
}

enum WorkOrderStatus {
  SCHEDULED
  STARTED
  CANCELLED
  COMPLETED
}

// Roles for application users
enum Role {
  ADMIN
}
